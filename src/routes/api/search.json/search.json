[{"title":"Introduction","href":"/index","description":"What is Svelte Simple * ?","content":"import { Callout } from '@svecodocs/kit'   Svelte Simple \\* is a suite of libraries designed to simplify the development process of Svelte applications. Its primary focus is on ease of use, making it an ideal choice for developers of all skill levels.  By providing a collection of simple, yet powerful tools, Svelte Simple enables developers to quickly and easily build high-quality web applications. Whether you're building a simple website or a complex web application, Svelte Simple has the tools you need to get the job done.  Tools  Svelte Simple Form**. A simple yet powerful, lightweight form handling library for Svelte 5 or above Svelte Simple Query**. A simple yet powerful, lightweight data query library for Svelte 5 or above Svelte Simple Lang**. A lightweight library to manage multi-language (i18n) for Svelte 5 or above. It comes with a simple setup and much features.","category":"Overview"},{"title":"Examples","href":"/svelte-simple-lang/examples","description":"Examples of Svelte Simple Lang","content":"Hmmmm","category":"Svelte Simple Lang"},{"title":"Usage","href":"/svelte-simple-lang/usage","description":"Usage of Svelte Simple Lang","content":"Usage  Hei","category":"Svelte Simple Lang"},{"title":"Breaking changes","href":"/svelte-simple-form/breaking-changes","description":"Breaking changes of Svelte Simple Form","content":"0.2.5 => 0.3.0  1. Validation  Previously, validation was configured like this:  ... validation: { zod: schema } ...  Starting from the new version, the validation option has been removed. Validation is now fully manual and handled through onChange and onSubmit:  ... onChange: (field) => {   const err = validator.validateField(field, form.data);   if (err) form.setError(field, err);   else form.removeError(field); }, ... onSubmit: async (values) => {   const errors = validator.validateForm(values);   if (Object.keys(errors).length) {     form.errors = errors;     return;   }   ...   // API Action   ... } ...  This gives you complete freedom to use any validation library (Zod, Valibot, custom logic, etc.) without being locked into built-in helpers.  For more details, see the validation documentation: $2","category":"Svelte Simple Form"},{"title":"Examples","href":"/svelte-simple-form/examples","description":"Examples of Svelte Simple Form","content":"This section is still a work in progress.  In the meantime, you can explore the example implementations directly on GitHub:   https://github.com/harryhdt/svelte-simple-form/tree/main/src/examples","category":"Svelte Simple Form"},{"title":"Form actions","href":"/svelte-simple-form/form-actions","description":"Form actions of Svelte Simple Form","content":"In SvelteKit, a +page.server.js file can export actions, which allow you to POST data to the server using a standard `` element.  Learn more here:   https://svelte.dev/docs/kit/form-actions  Svelte Simple Form is not specifically designed for SvelteKit Form Actions.   The libraryâ€™s API is intended for simple client-side form usage or API-based submissions.  However, if you still want to integrate it with SvelteKit Form Actions, you can align both approaches using Progressive Enhancement.  SvelteKit provides the use:enhance directive for this purpose:   https://svelte.dev/docs/kit/form-actions#Progressive-enhancement  With use:enhance, you can keep using Svelte Simple Form on the client side while still benefiting from SvelteKitâ€™s server-side form handling when needed.","category":"Svelte Simple Form"},{"title":"Installation","href":"/svelte-simple-form/installation","description":"Installation of Svelte Simple Form","content":"npm install svelte-simple-form  Note: This hook is built to work seamlessly with Svelte 5's reactive system, using $state, $effect, and tick. Make sure your project is on Svelte 5 or later.","category":"Svelte Simple Form"},{"title":"Introduction","href":"/svelte-simple-form/introduction","description":"Documentation Svelte Simple Form","content":"A lightweight, type-safe, and reactive form state management hook for Svelte 5, featuring:  Simply usage Zero dependencies Nested field paths support Dirty tracking, touched fields, and submission state Designed for Svelte 5â€™s new reactive primitives","category":"Svelte Simple Form"},{"title":"Usage","href":"/svelte-simple-form/usage","description":"Usage of Svelte Simple Form","content":"import { useForm } from \"svelte-simple-form\";  const { form } = useForm({   initialValues: {     name: \"John\",     email: \"\",     age: 10,     hobbies: [],     address: { country: \"\", zipCode: \"\" },   },   onSubmit: async (values) => {     console.log(values);   }, });  // form.data // form.errors // form.isDirty // form.isSubmitting // form.submit() // ...  ðŸŽ¯ useForm(props: FormProps)  Creates and returns the reactive form object managing form state and events.  Parameters  | Name            | Type                    | Description                         | | --------------- | ----------------------- | ----------------------------------- | | initialValues | T Automatically       | Initial values for the form fields. | | onSubmit      | Optional async callback | Called on successful submission.    | | onChange      | Optional callback       | Called on any field update.         | | onReset       | Optional callback       | Called when form resets.            |  Returns  {   form: {     initialValues: T;     data: T;     errors: Record, string[] | undefined>;     isValid: boolean;     isSubmitting: boolean;     isDirty: boolean;     touched: Record, boolean | undefined>;      setInitialValues(values: T, options?: { reset?: boolean }): void;     setIsDirty(dirty?: boolean): void;     setIsSubmitting(submitting?: boolean): void;      reset(): void;     resetField(field: Path): void;      setErrors(errors: Record, string[]>): void;     setError(field: Path, error: string | string[]): void;  removeError(field: Path): void;      submit(callback?: (data: T) => any): Promise;      handler(node: HTMLFormElement): void;   } }  ðŸ› ï¸ Methods & Usage Details  setInitialValues(values: T, options?: { reset?: boolean })  Set new initial values for the form. Optionally reset the current form data to the new initial values.  setIsDirty(dirty?: boolean)  Manually mark the form as dirty or clean.  setIsSubmitting(submitting?: boolean)  Manually set submitting state (e.g., show spinner).  reset()  Reset form data to initial values. Clear errors and touched fields. Calls onReset callback if provided.  resetField(field: Path)  Reset a single field (and its nested children) to its initial value. Clears touched state for the reset field.  setErrors(errors: Record, string[]>)  Replace all current errors with the given error map. Mostly used by full-form validation (e.g. schema validation on submit).  setError(field: Path, error: string | string[])  Set an error for a specific field manually. Useful for server-side validation (e.g. â€œemail already existsâ€). Does not affect other fieldsâ€™ errors.  removeError(field: Path)  Remove error from a specific field manually. Ideal after a previously invalid field becomes valid again. Does not change other errors.  submit(callback?: (data: T) => any)  Trigger submit form Manages isSubmitting state during async submission.  handler(node: HTMLFormElement)  Attach a native submit event listener to a form element. Calls submit() automatically on submit event, preventing default browser submission.  ðŸ’¡ Reactive State (Bind these in your Svelte components)  | Property            | Type                                     | Description                                    |     | | ------------------- | ---------------------------------------- | ---------------------------------------------- | --- | | form.data         | T                                      | Current form data, bind inputs here.           |     | | form.errors       | Record, string[] or undefined> | Validation errors keyed by path.               | | form.isValid      | boolean                                | True if form has no validation errors.         |     | | form.isSubmitting | boolean                                | True if form is currently submitting.          |     | | form.isDirty      | boolean                                | True if form data differs from initial values. |     | | form.touched      | Record\\, boolean or undefined> | Tracks which fields have been modified.        |  ðŸ§‘â€ðŸ’» Example Usage    import { useForm } from 'svelte-simple-form';   const { form } = useForm({   initialValues: {    name: 'John',    email: '',    age: 10   },   onSubmit: async (values) => {    await new Promise((resolve) => setTimeout(resolve, 2000));    console.log(values);   }  });              {form.isSubmitting ? 'Submitting...' : 'Submit'}     form.reset()}> Reset   ðŸ’¬ Tips & Notes  Designed specifically for Svelte 5, leveraging its reactive primitives ($state, $effect, tick). Supports deeply nested objects and arrays with full type safety via Path. Validation is unopinionated â€” you can use manual validation or any library you prefer, check docs for details. onChange is triggered for every changed field with path and new value, you can use it for validate field. Use form.isDirty to track if the user has modified the form. resetField allows fine-grained reset of individual nested fields. setError and removeError allows manual setting of error for specific field. Use form.handler directive to bind submit event easily. Use form.{state} = value for manually change state value Use form.{data|errors|touched}.{field} = value for manually change state field value initialValues does not support nested string paths (like \"body.height\"), use objects instead.","category":"Svelte Simple Form"},{"title":"Validation","href":"/svelte-simple-form/validation","description":"Validation of Svelte Simple Form","content":"Svelte Simple Form provides a flexible validation system that works on two levels:  Field validation** â€” runs when a specific field changes or loses focus Form validation** â€” runs before submit to validate all fields at once  A validator must provide two functions:  validator: {   validateField(field, form) {     // Validate single field     // Use form.setError(field, errors)     // or form.removeError(field)   },   validateForm(form) {     // Validate all fields     // Use form.setErrors(allErrors)   }, },  Validation results are applied using:  form.setError(field, errors) â†’ set errors for a single field form.removeError(field) â†’ clear errors for a single field form.setErrors(errors) â†’ set all errors at once  Examples  We have two example of validator  1. Zod  Use a Zod schema to validate form input, here is basic example of zodValidator.  Validator function zod.ts:  import type { FormContext } from \"svelte-simple-form\"; import type { ZodType } from \"zod\";  export function zodValidator>(   schema: T,   options:     | {         dependencies?: Partial>;       }     | undefined = undefined ) {   function mapErrors(values: any) {     const res = schema.safeParse(values);     if (res.success) return {};     const errors: Record = {};     for (const issue of res.error.issues) {       const key = issue.path.join(\".\") || \"_form\";       (errors[key] ??= []).push(issue.message);     }     return errors;   }    return {     validateForm(form: FormContext) {       form.setErrors({});       const errors = mapErrors(form.data);       if (Object.keys(errors).length) {         form.setErrors(errors);         return false;       } else {         return true;       }     },     validateField(field: string, form: FormContext) {       const allErrors = mapErrors(form.data);       const deps = options?.dependencies?.[field] ?? [];       const fieldsToCheck = [field, ...deps];       let valid = true;       for (const key of fieldsToCheck) {         if (!form.touched[key]) continue;         const errs = allErrors[key];         if (errs && errs.length > 0) {           valid = false;           form.setError(key, errs);         } else {           form.removeError(key);         }       }       return valid;     },   }; }  This is a very simple example validator for Zod.  It validates the whole form even when only one field changes, so it may not be the most efficient solution for large forms.  You are welcome to create a more optimized version  Usage example:  const schema = z   .object({     name: z.string().min(1, \"Required\"),     password: z.string().min(6, \"Min 6 chars\"),     confirmPassword: z.string().min(6, \"Min 6 chars\"),   })   .refine((data) => data.password === data.confirmPassword, {     message: \"Passwords do not match\",     path: [\"confirmPassword\"],   });  const { form } = useForm({   initialValues: { name: \"\", password: \"\", confirmPassword: \"\" },   validator: zodValidator(schema, {     dependencies: {       password: [\"confirmPassword\"],       confirmPassword: [\"password\"],     },   }),   onSubmit: async (values) => {     console.log(\"submitted\", values);   }, });  ðŸ’¡ Use dependencies to revalidate related fields (e.g. password + confirmPassword)  2. Manual  Define your own validation rules using simple functions, here is basic example of manualValidator.  Validator function manual.ts:  /* eslint-disable @typescript-eslint/no-explicit-any */ import type { FormContext } from \"svelte-simple-form\";  export function manualValidator string | undefined> (   rules: T,   options?:     | {         dependencies?: Partial>;       }     | undefined ) {   function mapErrors(values: any) {     const errors: Record = {};      for (const key in rules) {       const rule = rules[key];       const message = rule(values[key], values);       if (message) {         (errors[key] ??= []).push(message);       }     }      return errors;   }    return {     validateForm(form: FormContext) {       form.setErrors({});       const errors = mapErrors(form.data);       if (Object.keys(errors).length) {         form.setErrors(errors);         return false;       }       return true;     },      validateField(field: string, form: FormContext) {       const allErrors = mapErrors(form.data);       const deps = options?.dependencies?.[field] ?? [];       const fieldsToCheck = [field, ...deps];        let valid = true;        for (const key of fieldsToCheck) {         if (!form.touched[key]) continue;          const errs = allErrors[key];         if (errs && errs.length > 0) {           valid = false;           form.setError(key, errs);         } else {           form.removeError(key);         }       }        return valid;     },   }; }  Usage example:  const { form } = useForm({   initialValues: { name: \"\", password: \"\", confirmPassword: \"\" },   validator: manualValidator(     {       name: (v) => {         if (!v) return \"Required\";         if (v.length  {         if (!v) return \"Required\";         if (v.length  {         if (!v) return \"Required\";         if (v !== all.password) return \"Passwords do not match\";       },     },     {       dependencies: {         password: [\"confirmPassword\"],         confirmPassword: [\"password\"],       },     }   ),   onSubmit: async (values) => {     console.log(\"submitted\", values);   }, });  This is great if you donâ€™t want to rely on an external library.  Use with Other Validation Libraries  The validator API is fully flexible. You can integrate any validation library â€” such as:  Yup Superstruct Vest Valibot Joi (browser compatible versions) etc.  All you need to do is:  Parse your form data using the libraryâ€™s validation method Convert the validation result to a simple error map Update the form using form.setError, form.removeError, or form.setErrors  This means you are free to choose (or build) the validation strategy that fits your needs.","category":"Svelte Simple Form"},{"title":"Examples","href":"/svelte-simple-query/examples","description":"Examples of Svelte Simple Query","content":"Hmmmm","category":"Svelte Simple Query"},{"title":"Usage","href":"/svelte-simple-query/usage","description":"Usage of Svelte Simple Query","content":"Usage  Hei","category":"Svelte Simple Query"}]